// // RobotBuilder Version: 3.1
// //
// // This file was generated by RobotBuilder. It contains sections of
// // code that are automatically generated and assigned by robotbuilder.
// // These sections will be updated in the future when you export to
// // Java from RobotBuilder. Do not put any code or make any change in
// // the blocks indicating autogenerated code or it will be lost on an
// // update. Deleting the comments indicating the section will prevent
// // it from being updated in the future.


// package frc.robot.commands;
// import edu.wpi.first.wpilibj2.command.CommandBase;
// import frc.robot.LimelightUtility;
// import frc.robot.RobotContainer;
// // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
// import frc.robot.subsystems.DriveTrain;

//     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

// /**
//  *
//  */
// public class turn2LimeLight extends CommandBase {

//     // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
//         private final DriveTrain m_driveTrain;
 
//     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

//     // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS


//     public turn2LimeLight(DriveTrain subsystem) {


//     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
//         // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

//     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
//         // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

//         m_driveTrain = subsystem;
//         addRequirements(m_driveTrain);

//     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
//     }
//     private double targetTurn;
//     private boolean targetAcquired = false;
//     private double ledWarmUp = 50;
//     private double twist = 0;
//     private float Kp = -0.05f;
//     private float min_command = 0.3f;
//     private float tx = 0;
//     private boolean firstSight = true;


//     // Called when the command is initially scheduled.
//     @Override
//     public void initialize() {
//         LimelightUtility.EnableDriverCamera(false);
//         LimelightUtility.WriteDouble("ledMode", 3); // 3 = Limelight On
//         ledWarmUp = 25;
//         m_driveTrain.zeroSensors();
//         LimelightUtility.RefreshTrackingData();
//         targetAcquired = LimelightUtility.ValidTargetFound();
//         tx = (float)  getTargetTurn();
//         targetTurn = getTargetTurn();
//         firstSight=true;

//     }

//     // Called every time the scheduler runs while the command is scheduled.
//     @Override
//     public void execute() {
//         LimelightUtility.RefreshTrackingData();
//         targetAcquired = LimelightUtility.ValidTargetFound();
//         targetTurn = getTargetTurn();
//         System.out.println("Target aquired=" + targetAcquired);
//         System.out.println("LED warmup=" + ledWarmUp);
//         System.out.println("First sight=" + firstSight);
//         System.out.println("Target Turn=" + targetTurn);
//         if (ledWarmUp <= 0 && targetAcquired && firstSight) {
//             System.out.println("Limelight angle=" + targetTurn);
//             System.out.println("Calculated angle=" + Math.atan(Math.tan(Math.toRadians(59.6))*targetTurn/160));
//             targetTurn = Math.atan(Math.tan(Math.toRadians(59.6))*targetTurn/160)*100;
//             System.out.println("target turn=" + targetTurn);
//             m_driveTrain.closedLoopTurn(targetTurn);
//             firstSight=false;
//         }


//     //    LimelightUtility.RefreshTrackingData();
//     //    targetAcquired = LimelightUtility.ValidTargetFound();
//     //    tx = -(float)getTargetTurn();
//     //    float steering_adjust = 0.0f;
//     //    float heading_error = tx;
//     //     if (targetAcquired) {
//     //        // targetTurn = -getTargetTurn();
//     //        System.out.println("target turn=" + tx);
            
//     //        // m_driveTrain.closedLoopTurn(targetTurn);
//     //        steering_adjust = heading_error/28;

//     //        if (Math.abs(steering_adjust) < .3){
//     //             if (steering_adjust < 0)
//     //                 steering_adjust = -0.3f;
//     //             else
//     //                 steering_adjust = 0.3f;
//     //        }

//     //       System.out.println("twiste=" + steering_adjust);
//     //        m_driveTrain.tankDrive.arcadeDrive(0,steering_adjust);
//     //     }
//         ledWarmUp--;
//     }
    

//     // Called once the command ends or is interrupted.
//     @Override
//     public void end(boolean interrupted) {
//         m_driveTrain.stop();    
        
//     }

//     // Returns true when the command should end.
//     @Override
//     public boolean isFinished() {
//           boolean turnComplete = m_driveTrain.closedLoopTurnComplete(targetTurn);
//    //     boolean turnComplete = Math.abs(getTargetTurn()) < 1;
//         System.out.println("complete=" + turnComplete);

//         return (turnComplete && (ledWarmUp <= 0));
//     }

//     @Override
//     public boolean runsWhenDisabled() {
//         // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
//         return false;

//     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        
//     }
//     private double getTargetTurn() {
//         LimelightUtility.RefreshTrackingData();
//         return -LimelightUtility.TargetHorizontalOffset;
//     }
// }
